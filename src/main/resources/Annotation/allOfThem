# توضیح کامل Annotationهای Spring

## **۱. `@Component`**
```java
@Component
public class EmailService {
    // ...
}
```
**کاربرد:** علامت گذاری کلاس به عنوان یک Bean که توسط Spring مدیریت می‌شود
**توضیح:** پایه‌ای ترین annotation برای تعریف Bean. Spring کلاس‌های دارای این annotation را اسکن کرده و آن‌ها را به عنوان Bean ثبت می‌کند.

---

## **۲. `@Service`**
```java
@Service
public class OrderService {
    // ...
}
```
**کاربرد:** مشخص کردن کلاس‌های لایه Business Logic
**توضیح:** نوع خاصی از `@Component` که معنای سمانتیکی دارد. نشان می‌دهد این کلاس حاوی منطق کسب‌وکار است.

---

## **۳. `@Repository`**
```java
@Repository
public class UserRepository {
    // ...
}
```
**کاربرد:** مشخص کردن کلاس‌های لایه Data Access (DAOs)
**توضیح:**
- تبدیل استثناهای خاص دیتابیس به استثناهای Spring
- پشتیبانی از declarative transactions
- نشان‌دهنده کلاسی که با دیتابیس کار می‌کند

---

## **۴. `@Controller`**
```java
@Controller
public class UserController {
    @RequestMapping("/users")
    public String getUsers() {
        return "users";
    }
}
```
**کاربرد:** مشخص کردن کلاس‌های کنترلر در معماری MVC
**توضیح:** برای مدیریت درخواست‌های وب و بازگرداندن view

---

## **۵. `@RestController`**
```java
@RestController
public class UserApiController {
    @GetMapping("/api/users")
    public List<User> getUsers() {
        return userService.findAll();
    }
}
```
**کاربرد:** ایجاد RESTful web services
**توضیح:** ترکیب `@Controller` + `@ResponseBody`. داده‌ها را به صورت JSON/XML برمی‌گرداند.

---

## **۶. `@Configuration`**
```java
@Configuration
public class AppConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
}
```
**کاربرد:** مشخص کردن کلاس‌های configuration
**توضیح:** Spring این کلاس‌ها را اسکن می‌کند تا تعریف Beanها را پیدا کند.

---

## **۷. `@Bean`**
```java
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}
```
**کاربرد:** تعریف Bean در کلاس‌های Configuration
**توضیح:** متدهای دارای این annotation یک Bean برمی‌گردانند که توسط Spring مدیریت می‌شود.

---

## **۸. `@Autowired`**
```java
@Service
public class OrderService {
    @Autowired
    private UserRepository userRepository;
}
```
**کاربرد:** تزریق خودکار وابستگی‌ها
**توضیح:** Spring به صورت خودکار Bean مناسب را پیدا کرده و تزریق می‌کند.

---

## **۹. `@Qualifier`**
```java
@Service
public class PaymentService {
    @Autowired
    @Qualifier("creditCardProcessor")
    private PaymentProcessor processor;
}
```
**کاربرد:** مشخص کردن Bean خاص وقتی چند Bean از یک نوع وجود دارد
**توضیح:** وقتی چندین Bean از یک نوع داریم، با این annotation مشخص می‌کنیم کدام یک تزریق شود.

---

## **۱۰. `@Value`**
```java
@Service
public class EmailService {
    @Value("${app.email.sender}")
    private String senderEmail;

    @Value("${app.email.retry.count:3}")
    private int retryCount;
}
```
**کاربرد:** تزریق مقادیر از فایل‌های properties
**توضیح:** مقدار property را از `application.properties` خوانده و تزریق می‌کند.

---

## **۱۱. `@Profile`**
```java
@Configuration
@Profile("dev")
public class DevDatabaseConfig {
    // فقط در profile dev فعال می‌شود
}

@Bean
@Profile("production")
public DataSource productionDataSource() {
    // فقط در profile production فعال می‌شود
}
```
**کاربرد:** فعال/غیرفعال کردن Beanها بر اساس environment
**توضیح:** Bean فقط وقتی فعال می‌شود که profile مشخص شده فعال باشد.

---

## **۱۲. `@Transactional`**
```java
@Service
@Transactional
public class BankService {
    public void transferMoney(Account from, Account to, double amount) {
        // اگر خطایی رخ دهد، تمام تغییرات rollback می‌شوند
    }
}
```
**کاربرد:** مدیریت declarative transactions
**توضیح:**
- اگر متد با موفقیت اجرا شود، commit می‌شود
- اگر exception رخ دهد، rollback می‌شود
- می‌تواند در سطح کلاس یا متد استفاده شود

---

## **۱۳. `@Async`**
```java
@Service
public class NotificationService {
    @Async
    public CompletableFuture<String> sendEmailAsync(String to) {
        // این متد به صورت ناهمزمان اجرا می‌شود
        return CompletableFuture.completedFuture("Email sent");
    }
}
```
**کاربرد:** اجرای متد به صورت ناهمزمان (در thread جداگانه)
**توضیح:** Spring یک proxy ایجاد کرده و متد را در thread جداگانه اجرا می‌کند.

---

## **۱۴. `@Scheduled`**
```java
@Service
public class ReportService {
    @Scheduled(fixedRate = 5000)
    public void generateReport() {
        // هر ۵ ثانیه اجرا می‌شود
    }

    @Scheduled(cron = "0 0 2 * * *")
    public void dailyCleanup() {
        // هر روز ساعت ۲ بامداد اجرا می‌شود
    }
}
```
**کاربرد:** اجرای متد در زمان‌های مشخص شده
**انواع:**
- `fixedRate`: هر X میلی‌ثانیه
- `fixedDelay`: X میلی‌ثانیه بعد از اتمام اجرای قبلی
- `cron`: با expression cron

---

## **۱۵. `@EventListener`**
```java
@Service
public class OrderEventListener {
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        // وقتی OrderCreatedEvent انتشار یابد، این متد اجرا می‌شود
    }
}
```
**کاربرد:** گوش دادن به events انتشار یافته در برنامه
**توضیح:** متد وقتی اجرا می‌شود که event مربوطه publish شود.

---

## **۱۶. `@Validated`**
```java
@Service
@Validated
public class UserService {
    public void createUser(@Valid User user) {
        // user به صورت خودکار validate می‌شود
    }

    public User getUser(@Min(1) Long id) {
        // پارامتر id validate می‌شود
    }
}
```
**کاربرد:** فعال کردن validation روی متدها و پارامترها
**توضیح:** پارامترهای متد و اشیاء به صورت خودکار validate می‌شوند.

---

## **۱۷. Annotationهای اضافی مهم:**

### **`@RequestMapping`**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    @GetMapping
    public List<User> getAll() { }

    @PostMapping
    public User create(@RequestBody User user) { }

    @PutMapping("/{id}")
    public User update(@PathVariable Long id, @RequestBody User user) { }

    @DeleteMapping("/{id}")
    public void delete(@PathVariable Long id) { }
}
```

### **`@PathVariable` و `@RequestParam`**
```java
@GetMapping("/users/{userId}/orders")
public List<Order> getUserOrders(
    @PathVariable Long userId,
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "10") int size
) { }
```

### **`@RequestBody` و `@ResponseBody`**
```java
@PostMapping
public User createUser(@RequestBody User user) {
    // @RequestBody: JSON ورودی به User object تبدیل می‌شود
    // @ResponseBody: خروجی به صورت خودکار به JSON تبدیل می‌شود
    return userService.save(user);
}
```

## **مثال کاربردی ترکیبی:**

```java
@SpringBootApplication
@EnableAsync
@EnableScheduling
@EnableTransactionManagement
public class EcommerceApplication {
    public static void main(String[] args) {
        SpringApplication.run(EcommerceApplication.class, args);
    }
}

@Service
@Transactional
@Validated
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    @Value("${app.max-order-amount}")
    private double maxOrderAmount;

    @Async
    public CompletableFuture<Order> processOrderAsync(@Valid Order order) {
        return CompletableFuture.completedFuture(processOrder(order));
    }

    @Transactional(readOnly = true)
    public Order getOrder(@Min(1) Long orderId) {
        return orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("Order not found"));
    }

    @EventListener
    @Async
    public void handlePaymentCompleted(PaymentCompletedEvent event) {
        // پردازش ناهمزمان event
        completeOrder(event.getOrderId());
    }
}
```

این annotationها به Spring کمک می‌کنند تا جنبه‌های مختلف برنامه را به صورت declarative مدیریت کند و کد تمیزتر و قابل نگهداری‌تری داشته باشیم.